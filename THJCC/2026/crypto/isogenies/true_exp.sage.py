

# This file was *autogenerated* from the file true_exp.sage
from sage.all_cmdline import *   # import sage library

_sage_const_13 = Integer(13); _sage_const_7 = Integer(7); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_6 = Integer(6); _sage_const_11067381 = Integer(11067381); _sage_const_1118198 = Integer(1118198); _sage_const_8021433 = Integer(8021433); _sage_const_1906048 = Integer(1906048); _sage_const_8959148 = Integer(8959148); _sage_const_2448181 = Integer(2448181); _sage_const_10026959 = Integer(10026959); _sage_const_706144 = Integer(706144); _sage_const_16 = Integer(16)
from sage.all import *
from Crypto.Cipher import AES
import hashlib

# --- 1. 環境設定 ---
ea, eb = _sage_const_13 , _sage_const_7 
p = _sage_const_2 **ea * _sage_const_3 **eb - _sage_const_1 
K = GF(p**_sage_const_2 , modulus=x**_sage_const_2  + _sage_const_1 , names=('i',)); (i,) = K._first_ngens(1)
R = PolynomialRing(K, names=('y',)); (y,) = R._first_ngens(1)


# Output~
'''
E0: (0, 6, 0, 1, 0)
Eab: (0, 6, 0, 11067381*i + 1118198, 8021433*i + 1906048)
P_pub: (8959148*i + 2448181, 10026959*i + 706144)
ciphertext: 1aca81de78c79d95adc0b14f4dfb3c8121f900896c4ddd05fba6070f12f9a5ce94782503d5f8343ea8d237ea1eb13e76464a88cd4992fcad27e11af22b3fcd1a
'''
E0_inv = (_sage_const_0 , _sage_const_6 , _sage_const_0 , _sage_const_1 , _sage_const_0 )
Eab_inv = (_sage_const_0 , _sage_const_6 , _sage_const_0 , _sage_const_11067381 *i + _sage_const_1118198 , _sage_const_8021433 *i + _sage_const_1906048 )
P_pub_coords = (_sage_const_8959148 *i + _sage_const_2448181 , _sage_const_10026959 *i + _sage_const_706144 )
ciphertext_hex = "1aca81de78c79d95adc0b14f4dfb3c8121f900896c4ddd05fba6070f12f9a5ce94782503d5f8343ea8d237ea1eb13e76464a88cd4992fcad27e11af22b3fcd1a"

E0 = EllipticCurve(K, E0_inv)
Eab = EllipticCurve(K, Eab_inv)
P_pub = E0(P_pub_coords)

Phi2 = classical_modular_polynomial(_sage_const_2 )
Phi3 = classical_modular_polynomial(_sage_const_3 )

def get_all_next_js(Phi, jc):
    """允許回頭路，獲取所有鄰居"""
    f = Phi(jc, y)
    return [r for r, _ in f.roots()]

# --- 2. 精確深度搜尋 (允許回頭路) ---
def build_full_tree(start_j, Phi, depth):
    # tree[d][curr_j] = [prev_js]
    tree = {d: {} for d in range(depth + _sage_const_1 )}
    tree[_sage_const_0 ][start_j] = [None]
    
    curr_nodes = [start_j]
    for d in range(depth):
        next_nodes = []
        for jc in curr_nodes:
            neighbors = get_all_next_js(Phi, jc)
            for jn in neighbors:
                if jn not in tree[d+_sage_const_1 ]:
                    tree[d+_sage_const_1 ][jn] = []
                    next_nodes.append(jn)
                tree[d+_sage_const_1 ][jn].append(jc)
        curr_nodes = next_nodes
    return tree

print(f"[*] 正在執行全路徑搜尋 (允許回頭路, ea={ea}, eb={eb})...")
tree_a = build_full_tree(E0.j_invariant(), Phi2, ea)
tree_b = build_full_tree(Eab.j_invariant(), Phi3, eb)

intersections = set(tree_a[ea].keys()) & set(tree_b[eb].keys())
print(f"[*] 發現 {len(intersections)} 個在精確深度重合的交點")

# --- 3. 路徑還原 ---
def get_paths_recursive(tree, depth, curr_j):
    if depth == _sage_const_0 :
        return [[curr_j]]
    all_p = []
    for prev_j in tree[depth][curr_j]:
        for p in get_paths_recursive(tree, depth - _sage_const_1 , prev_j):
            all_p.append(p + [curr_j])
    return all_p

def push_point_exhaustive(P, j_path, l):
    candidates = [P]
    for k in range(len(j_path) - _sage_const_1 ):
        target_j = j_path[k+_sage_const_1 ]
        next_gen = []
        for p in candidates:
            for phi in p.curve().isogenies_prime_degree(l):
                if phi.codomain().j_invariant() == target_j:
                    next_gen.append(phi(p))
        # 依據座標去重，但必須保留正負 y 的可能性
        unique = {pt.xy(): pt for pt in next_gen}
        candidates = list(unique.values())
    return candidates

# --- 4. 爆破解密 ---
ct_bytes = bytes.fromhex(ciphertext_hex)
iv, ct = ct_bytes[:_sage_const_16 ], ct_bytes[_sage_const_16 :]

for j_int in intersections:
    print(f"[*] 嘗試交點 {j_int}...")
    paths_a = get_paths_recursive(tree_a, ea, j_int)
    paths_b_rev = get_paths_recursive(tree_b, eb, j_int)
    
    for pa in paths_a:
        pts_ea = push_point_exhaustive(P_pub, pa, _sage_const_2 )
        for pb_from_eab in paths_b_rev:
            pb = pb_from_eab[::-_sage_const_1 ] # 反轉成 Ea -> Eab
            for p_ea in pts_ea:
                pts_final = push_point_exhaustive(p_ea, pb, _sage_const_3 )
                for pf in pts_final:
                    # 同構修正
                    iso = pf.curve().isomorphism_to(Eab)
                    p_correct = iso(pf)
                    
                    # 測試 P 與 -P
                    for cand in [p_correct, -p_correct]:
                        sx = cand.xy()[_sage_const_0 ]
                        # 嚴格模擬 chal.sage 的序列化格式
                        key = hashlib.sha256(str(sx).encode()).digest()[:_sage_const_16 ]
                        cipher = AES.new(key, AES.MODE_CBC, iv=iv)
                        dec = cipher.decrypt(ct)
                        
                        if b"THJCC" in dec:
                            print(f"\n[!] 成功！")
                            print(f"Flag: {dec[:-dec[-_sage_const_1 ]].decode()}")
                            exit()

