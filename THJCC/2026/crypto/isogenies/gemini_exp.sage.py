

# This file was *autogenerated* from the file gemini_exp.sage
from sage.all_cmdline import *   # import sage library

_sage_const_13 = Integer(13); _sage_const_7 = Integer(7); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_6 = Integer(6); _sage_const_11067381 = Integer(11067381); _sage_const_1118198 = Integer(1118198); _sage_const_8021433 = Integer(8021433); _sage_const_1906048 = Integer(1906048); _sage_const_8959148 = Integer(8959148); _sage_const_2448181 = Integer(2448181); _sage_const_10026959 = Integer(10026959); _sage_const_706144 = Integer(706144); _sage_const_16 = Integer(16); _sage_const_500 = Integer(500)
from sage.all import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import hashlib

# 1. 初始化參數
ea, eb = _sage_const_13 , _sage_const_7 
p = _sage_const_2 **ea * _sage_const_3 **eb - _sage_const_1 
K = GF(p**_sage_const_2 , modulus=x**_sage_const_2  + _sage_const_1 , names=('i',)); (i,) = K._first_ngens(1)

E0 = EllipticCurve(K, [_sage_const_0 , _sage_const_6 , _sage_const_0 , _sage_const_1 , _sage_const_0 ])
# 題目給的 Eab invariants
Eab_inv = (_sage_const_0 , _sage_const_6 , _sage_const_0 , _sage_const_11067381 *i + _sage_const_1118198 , _sage_const_8021433 *i + _sage_const_1906048 )
Eab_target = EllipticCurve(K, list(Eab_inv))
target_j = Eab_target.j_invariant()

P_pub = E0(_sage_const_8959148 *i + _sage_const_2448181 , _sage_const_10026959 *i + _sage_const_706144 )
ciphertext = bytes.fromhex("1aca81de78c79d95adc0b14f4dfb3c8121f900896c4ddd05fba6070f12f9a5ce94782503d5f8343ea8d237ea1eb13e76464a88cd4992fcad27e11af22b3fcd1a")

def get_isogeny_chain(E, l, e, secret):
    curr_E = E
    phis = []
    for j in range(e):
        P, Q = curr_E.torsion_basis(l**(e-j))
        kernel_pt = (P + secret * Q) * l**(e-j-_sage_const_1 )
        phi = curr_E.isogeny(kernel_pt)
        phis.append(phi)
        curr_E = phi.codomain()
    return curr_E, phis

def push_point(phi_list, P):
    curr_P = P
    for phi in phi_list:
        curr_P = phi(curr_P)
    return curr_P

# 2. 爆破 sa 並儲存 Ea 的 j-invariant
print("[*] Searching for sa and sb...")
found = False
for sa in range(_sage_const_2 **ea):
    Ea, phis_a = get_isogeny_chain(E0, _sage_const_2 , ea, sa)
    # 對於每一個 Ea，檢查是否能透過 sb 到達目標 Eab
    # 這裡使用內層循環，因為 sb 空間很小 (2187)
    for sb in range(_sage_const_3 **eb):
        Eab_test, phis_b = get_isogeny_chain(Ea, _sage_const_3 , eb, sb)
        if Eab_test.j_invariant() == target_j:
            # 進一步確認 a-invariants 是否完全匹配
            if Eab_test.a_invariants() == Eab_inv:
                print(f"[+] Found! sa: {sa}, sb: {sb}")
                
                # 3. 計算共享點 P_priv
                P_priv = push_point(phis_b, push_point(phis_a, P_pub))
                shared_x = P_priv.xy()[_sage_const_0 ]
                
                # 4. 解密 Flag
                key = hashlib.sha256(str(shared_x).encode()).digest()[:_sage_const_16 ]
                iv = ciphertext[:_sage_const_16 ]
                ct = ciphertext[_sage_const_16 :]
                cipher = AES.new(key, AES.MODE_CBC, iv=iv)
                flag = unpad(cipher.decrypt(ct), _sage_const_16 )
                print(f"[!] Flag: {flag.decode()}")
                found = True
                break
    if found: break
    if sa % _sage_const_500  == _sage_const_0 : print(f"Progress: sa={sa}...")

